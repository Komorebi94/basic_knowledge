### UDP

-   UDP 协议是面向无连接的，无须在传递数据之前先连接双方
-   UDP 不保证有序且不丢失的传递到对端
-   没有任何控制流量的算法
-   传递高效，常用的场景有直播，游戏

### TCP 的三次握手

-   URG：紧急指针（urgent pointer）有效。
-   ACK：确认序号有效。
-   PSH：接收方应该尽快将这个报文交给应用层。
-   RST：重置连接。
-   SYN：发起一个新连接。
-   FIN：释放一个连接
-   seq: 序号 
-   ack: 确认号
-   第一次握手：建立连接时，客户端发送 数据包(标记位 SYN = 1, seq = x)到服务器，并进入 SYN_SENT 状态，等待服务器的确认
-   第二次握手：服务器收到客户端的数据包，需要确认客户端的 Seq 序号有效，向客户端发送数据包(标记为 SYN = 1,ACK = 1; seq = y, ack = x+ 1)此时服务器进入 SYN_RECV 状态
-   第三次握手：客户端收到服务器的数据包，向服务器发送确认包(标记为 ACK = 1,seq = x+1,ack = y+1),此包发送完毕，客户端和服务器进入 ESTABLISHED(TCP 连接成功)状态, 完成三次握手
    ![tcp1.jpeg](./img/tcp1.jpeg)

### 为什么 TCP 建立连接需要三次握手，明明两次就可以？

-   为了防止出现失效的连接请求报文段被服务器接收导致服务器资源的浪费
-   比如：客户端发送了一个连接请求 A，但是因为网络的原因造成了超时，这时 TCP 会启动超时重传机制再发送一个连接请求 B，此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。此时请求 A 也到了服务端，那么服务端会认为客户端又需要建立一个新的连接，从而应答了该请求并进入了 ESTABLISHED 状态，这样就会导致服务端一直等待，造成资源的浪费

### TCP 的四次挥手

-   第一次挥手：客户端想要关闭连接，发送数据包(标记位：FIN = 1, seq = u)到服务器，客户端进入 FIN-WAIT-1 半关闭状态
-   第二次挥手：服务端发送数据包(标记位：ACK=1,seq=v,ack=u+1)到客户端，并进入 CLOSE-WAIT 状态，客户端收到后进入 FIN-WAIT-2 阶段
-   第三次握手：服务端发送数据包(标记位：FIN = 1, ACK = 1, seq = w, ack = u + 1)，服务端进入 LAST-ACK 最后确认状态
-   第四次握手：客户端发送数据包(标记位：ACK = 1, seq = u + 1, ack = w + 1), 客户端进入 TIME-WAIT 状态, 服务端收到之后进入 CLOSED 状态， 客户端等待 2MSL 后进入 CLOSED 状态
    ![tcp2.jpeg](./img/tcp2.jpeg)


### 对称加密和非对称加密

-   1、对称加密中加密和解密使用的秘钥是同一个；非对称加密中采用两个密钥，一般使用公钥进行加密，私钥进行解密。
-   2、对称加密解密的速度比较快，非对称加密和解密花费的时间长、速度相对较慢。
-   3、对称加密的安全性相对较低，非对称加密的安全性较高。
-   首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。

### 为什么出现了https?

-   由于 HTTP 的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。于是我们在 HTTP 协议栈的 TCP 和 HTTP 层之间插入了一个安全层，负责数据的加密和解密操作。
-   我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。
-   采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。